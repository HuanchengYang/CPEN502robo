<html>
<head>
<title>BackPropagationLUT.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #629755; font-weight: bold; font-style: italic;}
.s6 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
BackPropagationLUT.java</font>
</center></td></tr></table>
<pre><span class="s0">package </span><span class="s1">NeuralNetwork</span><span class="s0">;</span>


<span class="s0">import </span><span class="s1">LUT.LUT</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">robot.Action</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">robot.Learner</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">robot.State</span><span class="s0">;</span>

<span class="s0">import </span><span class="s1">java.io.*</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">java.util.ArrayList</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">java.util.Arrays</span><span class="s0">;</span>

<span class="s0">public class </span><span class="s1">BackPropagationLUT </span><span class="s0">extends </span><span class="s1">NeuralNetLUT </span><span class="s0">implements </span><span class="s1">NeuralNetInterface {</span>
    <span class="s0">final int </span><span class="s1">numLayer = </span><span class="s2">1</span><span class="s0">;</span>
    <span class="s0">final int </span><span class="s1">argNumOutputs = </span><span class="s2">1</span><span class="s0">;</span>
    <span class="s0">final int </span><span class="s1">biasConstant = </span><span class="s2">1</span><span class="s0">;</span>


    <span class="s0">double </span><span class="s1">[][][] weight</span><span class="s0">;</span>
    <span class="s0">double </span><span class="s1">[][] error</span><span class="s0">;</span>
    <span class="s0">double </span><span class="s1">[][] value</span><span class="s0">;</span>
    <span class="s0">double </span><span class="s1">[][][] weightChange</span><span class="s0">;</span>
    <span class="s0">double </span><span class="s1">[][][] newweight</span><span class="s0">;</span>

    <span class="s1">ArrayList&lt;ArrayList&lt;Double&gt;&gt; trainingInput= </span><span class="s0">new </span><span class="s1">ArrayList&lt;ArrayList&lt;Double&gt;&gt;()</span><span class="s0">;</span>
    <span class="s1">ArrayList&lt;Double&gt; trainingOutput = </span><span class="s0">new </span><span class="s1">ArrayList&lt;Double&gt;()</span><span class="s0">;</span>
    <span class="s0">double </span><span class="s1">[][] arrayTrainingInput = </span><span class="s0">new double</span><span class="s1">[][]{}</span><span class="s0">;</span>
    <span class="s0">double </span><span class="s1">[] arrayTrainingOutput = </span><span class="s0">new double</span><span class="s1">[]{}</span><span class="s0">;</span>
    <span class="s0">double </span><span class="s1">[] normalizedarrayTrainingOutput</span><span class="s0">;</span>





    <span class="s0">public </span><span class="s1">BackPropagationLUT() {</span>
        <span class="s0">this</span><span class="s1">.argNumInputs = </span><span class="s2">11</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.argNumHidden = </span><span class="s2">80</span><span class="s0">;</span>
        <span class="s1">weight = </span><span class="s0">new double</span><span class="s1">[numLayer+</span><span class="s2">1</span><span class="s1">][][]</span><span class="s0">; </span><span class="s3">//one extra layer for output</span>
        <span class="s1">weight[</span><span class="s2">0</span><span class="s1">]= </span><span class="s0">new double</span><span class="s1">[argNumHidden][argNumInputs+biasConstant]</span><span class="s0">;</span>
        <span class="s1">weight[</span><span class="s2">1</span><span class="s1">]= </span><span class="s0">new double</span><span class="s1">[argNumOutputs][argNumHidden+biasConstant]</span><span class="s0">;</span>
        <span class="s1">newweight = </span><span class="s0">new double</span><span class="s1">[numLayer+</span><span class="s2">1</span><span class="s1">][][]</span><span class="s0">; </span><span class="s3">//one extra layer for output</span>
        <span class="s1">newweight[</span><span class="s2">0</span><span class="s1">]= </span><span class="s0">new double</span><span class="s1">[argNumHidden][argNumInputs+biasConstant]</span><span class="s0">;</span>
        <span class="s1">newweight[</span><span class="s2">1</span><span class="s1">]= </span><span class="s0">new double</span><span class="s1">[argNumOutputs][argNumHidden+biasConstant]</span><span class="s0">;</span>
        <span class="s1">weightChange = </span><span class="s0">new double</span><span class="s1">[numLayer+</span><span class="s2">1</span><span class="s1">][][]</span><span class="s0">; </span><span class="s3">//one extra layer for output</span>
        <span class="s1">weightChange[</span><span class="s2">0</span><span class="s1">]= </span><span class="s0">new double</span><span class="s1">[argNumHidden][argNumInputs+biasConstant]</span><span class="s0">;</span>
        <span class="s1">weightChange[</span><span class="s2">1</span><span class="s1">]= </span><span class="s0">new double</span><span class="s1">[argNumOutputs][argNumHidden+biasConstant]</span><span class="s0">;</span>
        <span class="s1">error = </span><span class="s0">new double</span><span class="s1">[numLayer+</span><span class="s2">1</span><span class="s1">][]</span><span class="s0">;</span>
        <span class="s1">error[</span><span class="s2">0</span><span class="s1">] = </span><span class="s0">new double</span><span class="s1">[argNumHidden]</span><span class="s0">;</span>
        <span class="s1">error[</span><span class="s2">1</span><span class="s1">] = </span><span class="s0">new double</span><span class="s1">[argNumOutputs]</span><span class="s0">;</span>
        <span class="s1">value = </span><span class="s0">new double</span><span class="s1">[numLayer+</span><span class="s2">2</span><span class="s1">][]</span><span class="s0">;</span>
        <span class="s1">value[</span><span class="s2">0</span><span class="s1">] = </span><span class="s0">new double</span><span class="s1">[argNumInputs+biasConstant]</span><span class="s0">;</span>
        <span class="s1">value[</span><span class="s2">1</span><span class="s1">] = </span><span class="s0">new double</span><span class="s1">[argNumHidden+biasConstant]</span><span class="s0">;</span>
        <span class="s1">value[</span><span class="s2">2</span><span class="s1">] = </span><span class="s0">new double</span><span class="s1">[argNumOutputs]</span><span class="s0">;</span>
        <span class="s1">value[</span><span class="s2">0</span><span class="s1">][argNumInputs]=</span><span class="s2">1</span><span class="s0">; </span><span class="s3">//Initialize Bias</span>
        <span class="s1">value[</span><span class="s2">1</span><span class="s1">][argNumHidden]=</span><span class="s2">1</span><span class="s0">; </span><span class="s3">//Initialize Bias</span>
    <span class="s1">}</span>




    <span class="s1">@Override</span>
    <span class="s3">/* 
      Return a bipolar sigmoid of the input X 
      @param x The input 
     * @return f(x) = 2 / (1+e(-x)) - 1 
     */</span>
    <span class="s0">public double </span><span class="s1">sigmoid(</span><span class="s0">double </span><span class="s1">x) {</span>
        <span class="s0">double </span><span class="s1">fx = </span><span class="s2">2.0 </span><span class="s1">/ (</span><span class="s2">1.0</span><span class="s1">+Math.exp(-x)) -</span><span class="s2">1.0</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">fx</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">public double </span><span class="s1">devsigmoid(</span><span class="s0">double </span><span class="s1">y) {</span>
        <span class="s0">return </span><span class="s2">0.5</span><span class="s1">*(</span><span class="s2">1.0</span><span class="s1">-Math.pow(y</span><span class="s0">,</span><span class="s2">2.0</span><span class="s1">))</span><span class="s0">;</span>
    <span class="s1">}</span>

<span class="s3">/* 
      Return a binary sigmoid of the input X 
      @param x The input 
     * @return f(x) = 2 / (1+e(-x)) - 1 
     */</span>

<span class="s3">//    public double sigmoid(double x){</span>
<span class="s3">//        return 1.0/(1.0+Math.exp(-x));</span>
<span class="s3">//    }</span>
<span class="s3">//</span>
<span class="s3">//    public double devsigmoid(double y) {</span>
<span class="s3">//        double dfx = y*(1.0-y);</span>
<span class="s3">//        return dfx;</span>
<span class="s3">//    }</span>

    <span class="s0">public double</span><span class="s1">[] findMaxOutput(</span><span class="s0">double</span><span class="s1">[] state){</span>
        <span class="s0">double </span><span class="s1">[] normalizedInput = </span><span class="s0">new double</span><span class="s1">[argNumInputs]</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">i&lt;normalizedInput.length</span><span class="s0">;</span><span class="s1">i++){</span>
            <span class="s0">if </span><span class="s1">(i&lt;state.length){</span>
                <span class="s1">normalizedInput[i]=state[i]</span><span class="s0">;</span>
            <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
                <span class="s1">normalizedInput[i]=</span><span class="s2">0</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">double </span><span class="s1">maxQ = -</span><span class="s2">500</span><span class="s0">;</span>
        <span class="s0">double</span><span class="s1">[] selectedAction = </span><span class="s0">new double</span><span class="s1">[</span><span class="s2">4</span><span class="s1">]</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">double </span><span class="s1">j=-</span><span class="s2">1</span><span class="s0">;</span><span class="s1">j&lt;=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">j=j+</span><span class="s2">0.5</span><span class="s1">){</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">double </span><span class="s1">k=-</span><span class="s2">1</span><span class="s0">;</span><span class="s1">k&lt;=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">k=k+</span><span class="s2">0.5</span><span class="s1">){</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">double </span><span class="s1">l=-</span><span class="s2">1</span><span class="s0">;</span><span class="s1">l&lt;=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">l=l+</span><span class="s2">0.5</span><span class="s1">){</span>
                    <span class="s0">for </span><span class="s1">(</span><span class="s0">double </span><span class="s1">m=-</span><span class="s2">1</span><span class="s0">;</span><span class="s1">m&lt;=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">m=m+</span><span class="s2">2</span><span class="s1">){</span>
                        <span class="s1">normalizedInput[state.length]=j</span><span class="s0">;</span>
                        <span class="s1">normalizedInput[state.length+</span><span class="s2">1</span><span class="s1">]=k</span><span class="s0">;</span>
                        <span class="s1">normalizedInput[state.length+</span><span class="s2">2</span><span class="s1">]=l</span><span class="s0">;</span>
                        <span class="s1">normalizedInput[state.length+</span><span class="s2">3</span><span class="s1">]=m</span><span class="s0">;</span>
                        <span class="s0">double </span><span class="s1">expectedQ=</span><span class="s0">this</span><span class="s1">.outputFor(normalizedInput)</span><span class="s0">;</span>
                        <span class="s0">if </span><span class="s1">(expectedQ&gt;maxQ){</span>
                            <span class="s1">maxQ=expectedQ</span><span class="s0">;</span>
                            <span class="s1">selectedAction = </span><span class="s0">new double</span><span class="s1">[]{j</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">l</span><span class="s0">, </span><span class="s1">m}</span><span class="s0">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">selectedAction</span><span class="s0">;</span>
    <span class="s1">}</span>


    <span class="s0">public double </span><span class="s1">findMaxQ(</span><span class="s0">double</span><span class="s1">[] state){</span>
        <span class="s0">double </span><span class="s1">[] normalizedInput = </span><span class="s0">new double</span><span class="s1">[argNumInputs]</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">i&lt;normalizedInput.length</span><span class="s0">;</span><span class="s1">i++){</span>
            <span class="s0">if </span><span class="s1">(i&lt;state.length){</span>
                <span class="s1">normalizedInput[i]=state[i]</span><span class="s0">;</span>
            <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
                <span class="s1">normalizedInput[i]=</span><span class="s2">0</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">double </span><span class="s1">maxQ = -</span><span class="s2">500</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">double </span><span class="s1">j=-</span><span class="s2">1</span><span class="s0">;</span><span class="s1">j&lt;=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">j=j+</span><span class="s2">0.5</span><span class="s1">){</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">double </span><span class="s1">k=-</span><span class="s2">1</span><span class="s0">;</span><span class="s1">k&lt;=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">k=k+</span><span class="s2">0.5</span><span class="s1">){</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">double </span><span class="s1">l=-</span><span class="s2">1</span><span class="s0">;</span><span class="s1">l&lt;=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">l=l+</span><span class="s2">0.5</span><span class="s1">){</span>
                    <span class="s0">for </span><span class="s1">(</span><span class="s0">double </span><span class="s1">m=-</span><span class="s2">1</span><span class="s0">;</span><span class="s1">m&lt;=</span><span class="s2">1</span><span class="s0">;</span><span class="s1">m=m+</span><span class="s2">2</span><span class="s1">){</span>
                        <span class="s1">normalizedInput[state.length]=j</span><span class="s0">;</span>
                        <span class="s1">normalizedInput[state.length+</span><span class="s2">1</span><span class="s1">]=k</span><span class="s0">;</span>
                        <span class="s1">normalizedInput[state.length+</span><span class="s2">2</span><span class="s1">]=l</span><span class="s0">;</span>
                        <span class="s1">normalizedInput[state.length+</span><span class="s2">3</span><span class="s1">]=m</span><span class="s0">;</span>
                        <span class="s0">double </span><span class="s1">expectedQ=</span><span class="s0">this</span><span class="s1">.outputFor(normalizedInput)</span><span class="s0">;</span>
                        <span class="s0">if </span><span class="s1">(expectedQ&gt;maxQ){</span>
                            <span class="s1">maxQ=expectedQ</span><span class="s0">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">maxQ</span><span class="s0">;</span>
    <span class="s1">}</span>


    <span class="s4">/**</span>
     <span class="s4">* This method implements a general sigmoid with asymptotes bounded by (a,b)</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">x The input</span>
     <span class="s4">* </span><span class="s5">@return </span><span class="s4">f(x) = b_minus_a / (1 + e(-x)) - minus_a</span>
     <span class="s4">*/</span>



    <span class="s1">@Override</span>
    <span class="s0">public double </span><span class="s1">customSigmoid(</span><span class="s0">double </span><span class="s1">x) {</span>
        <span class="s0">double </span><span class="s1">fx</span><span class="s0">;</span>
        <span class="s1">fx = (argB-argA) / (</span><span class="s2">1</span><span class="s1">+Math.exp(-x)) + argA</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">fx</span><span class="s0">;</span>
    <span class="s1">}</span>



    <span class="s4">/**</span>
     <span class="s4">* Initialize the weights to random values.</span>
     <span class="s4">* For say 2 inputs, the input vector is [0] &amp; [1]. We add [2] for the bias.</span>
     <span class="s4">* Like wise for hidden units. For say 2 hidden units which are stored in an array.</span>
     <span class="s4">* [0] &amp; [1] are the hidden &amp; [2] the bias.</span>
     <span class="s4">* We also initialise the last weight change arrays. This is to implement the alpha term.</span>
     <span class="s4">*/</span>

    <span class="s1">@Override</span>
    <span class="s0">public void </span><span class="s1">initializeWeights() {</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">k=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">k&lt;weight.length</span><span class="s0">;</span><span class="s1">k++) {</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">j = </span><span class="s2">0</span><span class="s0">; </span><span class="s1">j &lt; weight[k].length</span><span class="s0">; </span><span class="s1">j++) {</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s2">0</span><span class="s0">; </span><span class="s1">i &lt; weight[k][j].length</span><span class="s0">; </span><span class="s1">i++) {</span>
                    <span class="s1">weight[k][j][i] = Math.random() - </span><span class="s2">0.5</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">k=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">k&lt;newweight.length</span><span class="s0">;</span><span class="s1">k++) {</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">j = </span><span class="s2">0</span><span class="s0">; </span><span class="s1">j &lt; newweight[k].length</span><span class="s0">; </span><span class="s1">j++) {</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s2">0</span><span class="s0">; </span><span class="s1">i &lt; newweight[k][j].length</span><span class="s0">; </span><span class="s1">i++) {</span>
                    <span class="s1">newweight[k][j][i] = weight[k][j][i]</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">k=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">k&lt;weightChange.length</span><span class="s0">;</span><span class="s1">k++) {</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">j = </span><span class="s2">0</span><span class="s0">; </span><span class="s1">j &lt; weightChange[k].length</span><span class="s0">; </span><span class="s1">j++) {</span>
                <span class="s1">Arrays.fill(weightChange[k][j]</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">/**</span>
     <span class="s4">54 * Initialize the weights to 0.</span>
     <span class="s4">55 */</span>

    <span class="s1">@Override</span>
    <span class="s0">public void </span><span class="s1">zeroWeights() {</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">k=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">k&lt;weight.length</span><span class="s0">;</span><span class="s1">k++) {</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">j = </span><span class="s2">0</span><span class="s0">; </span><span class="s1">j &lt; weight[k].length</span><span class="s0">; </span><span class="s1">j++) {</span>
                <span class="s1">Arrays.fill(weight[k][j]</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

    <span class="s1">}</span>

    <span class="s0">public double </span><span class="s1">outputError(</span><span class="s0">double </span><span class="s1">actualY</span><span class="s0">,double </span><span class="s1">predictY){</span>
        <span class="s0">double </span><span class="s1">Oerror = (actualY-predictY)*devsigmoid(predictY)</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.error[numLayer][argNumOutputs-</span><span class="s2">1</span><span class="s1">]=Oerror</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">Oerror</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s3">//Compute all errors in hidden layer neuron</span>
    <span class="s0">public void </span><span class="s1">hiddenErrors(){</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">i&lt;argNumHidden</span><span class="s0">;</span><span class="s1">i++){</span>
            <span class="s1">hiddenError(value[</span><span class="s2">1</span><span class="s1">][i]</span><span class="s0">,</span><span class="s1">i</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">private void </span><span class="s1">hiddenError(</span><span class="s0">double </span><span class="s1">predictY</span><span class="s0">,int </span><span class="s1">index</span><span class="s0">,int </span><span class="s1">layer){</span>
        <span class="s0">double </span><span class="s1">Zerror</span><span class="s0">;</span>
        <span class="s0">double </span><span class="s1">sumPreError = </span><span class="s2">0</span><span class="s0">;</span>
<span class="s3">//        for (int i=0;i&lt;error[layer+1].length;i++) {</span>
<span class="s3">//            sumPreError += error[layer+1][i] * weight[layer+1][argNumOutputs-1][index];</span>
<span class="s3">//        }</span>
        <span class="s1">Zerror=devsigmoid(predictY)*error[numLayer][argNumOutputs-</span><span class="s2">1</span><span class="s1">]*weight[</span><span class="s2">1</span><span class="s1">][</span><span class="s2">0</span><span class="s1">][index]</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.error[layer][index]=Zerror</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">public void </span><span class="s1">weightUpdate(</span><span class="s0">int </span><span class="s1">weightLayer){</span>

            <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">j = weight[weightLayer].length-</span><span class="s2">1</span><span class="s0">; </span><span class="s1">j &gt;=</span><span class="s2">0</span><span class="s0">; </span><span class="s1">j--) {</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = weight[weightLayer][j].length-</span><span class="s2">1</span><span class="s0">; </span><span class="s1">i &gt;=</span><span class="s2">0</span><span class="s0">; </span><span class="s1">i--) {</span>
                    <span class="s1">newweight[weightLayer][j][i] = weight[weightLayer][j][i]+argMomentumTerm*weightChange[weightLayer][j][i]+argLearningRate*error[weightLayer][j]*value[weightLayer][i]</span><span class="s0">;</span>
                    <span class="s1">weightChange[weightLayer][j][i] = newweight[weightLayer][j][i]-weight[weightLayer][j][i]</span><span class="s0">;</span>
                    <span class="s1">weight[weightLayer][j][i]=newweight[weightLayer][j][i]</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

    <span class="s1">}</span>



    <span class="s1">@Override</span>
    <span class="s0">public double </span><span class="s1">outputFor(</span><span class="s0">double</span><span class="s1">[] X) {</span>
        <span class="s0">double </span><span class="s1">output=</span><span class="s2">0</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">m=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">m&lt;X.length</span><span class="s0">;</span><span class="s1">m++){</span>
            <span class="s1">value[</span><span class="s2">0</span><span class="s1">][m]=X[m]</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">i&lt;argNumHidden</span><span class="s0">;</span><span class="s1">i++){</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">j=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">j&lt;=argNumInputs</span><span class="s0">;</span><span class="s1">j++){</span>
                <span class="s1">output+=value[</span><span class="s2">0</span><span class="s1">][j]*weight[</span><span class="s2">0</span><span class="s1">][i][j]</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s1">value[</span><span class="s2">1</span><span class="s1">][i]=sigmoid(output)</span><span class="s0">;</span>
            <span class="s1">output=</span><span class="s2">0</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">output=</span><span class="s2">0</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">k=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">k&lt;=argNumHidden</span><span class="s0">;</span><span class="s1">k++){</span>
            <span class="s1">output+=value[</span><span class="s2">1</span><span class="s1">][k]*weight[</span><span class="s2">1</span><span class="s1">][</span><span class="s2">0</span><span class="s1">][k]</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">value[</span><span class="s2">2</span><span class="s1">][</span><span class="s2">0</span><span class="s1">]=sigmoid(output)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">value[</span><span class="s2">2</span><span class="s1">][</span><span class="s2">0</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s0">public double </span><span class="s1">train(</span><span class="s0">double</span><span class="s1">[] X</span><span class="s0">, double </span><span class="s1">argValue) {</span>
        <span class="s0">double </span><span class="s1">predictY=outputFor(X)</span><span class="s0">;</span>
        <span class="s0">double </span><span class="s1">error=Math.pow((predictY-argValue)</span><span class="s0">,</span><span class="s2">2</span><span class="s1">)</span><span class="s0">;</span>

        <span class="s1">outputError(argValue</span><span class="s0">, </span><span class="s1">predictY)</span><span class="s0">;</span>
        <span class="s1">weightUpdate(</span><span class="s2">1</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">hiddenErrors()</span><span class="s0">;</span>
        <span class="s1">weightUpdate(</span><span class="s2">0</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">error=(predictY-argValue)*(predictY-argValue)</span><span class="s0">;</span>
        <span class="s3">//System.out.println(&quot;Error is&quot;+error);</span>
        <span class="s0">return </span><span class="s1">error</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">public void </span><span class="s1">initializeTraining(LUT lut){</span>
        <span class="s1">Learner newlearn = </span><span class="s0">new </span><span class="s1">Learner(lut)</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">i&lt; State.NumofState</span><span class="s0">;</span><span class="s1">i++){</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">j=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">j&lt; Action.NumRobotActions</span><span class="s0">;</span><span class="s1">j++){</span>
                <span class="s0">if </span><span class="s1">(lut.getQValue(i</span><span class="s0">,</span><span class="s1">j)!=</span><span class="s2">0.0</span><span class="s1">){</span>
                    <span class="s0">double</span><span class="s1">[] state = newlearn.convertIntStatetoArray(i)</span><span class="s0">;</span>
                    <span class="s0">double</span><span class="s1">[] action= newlearn.convertIntActiontoArray(j)</span><span class="s0">;</span>
                    <span class="s0">double</span><span class="s1">[] normalizeInput = newlearn.normalizeInput(state</span><span class="s0">,</span><span class="s1">action)</span><span class="s0">;</span>
                    <span class="s1">ArrayList&lt;Double&gt; NetworkInput = convertArrayToArrayList(normalizeInput)</span><span class="s0">;</span>
                    <span class="s1">trainingInput.add(NetworkInput)</span><span class="s0">;</span>
                    <span class="s1">trainingOutput.add(lut.getQValue(i</span><span class="s0">,</span><span class="s1">j))</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">arrayTrainingInput = convert2DArrayListTo2DArray(trainingInput)</span><span class="s0">;</span>
        <span class="s1">arrayTrainingOutput = convertArrayListToArray(trainingOutput)</span><span class="s0">;</span>
        <span class="s1">normalizedarrayTrainingOutput=normalizeOutput(arrayTrainingOutput)</span><span class="s0">;</span>


        <span class="s1">trainModel(arrayTrainingInput</span><span class="s0">,</span><span class="s1">normalizedarrayTrainingOutput)</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">public void </span><span class="s1">updateValueAndRetrain(</span><span class="s0">double</span><span class="s1">[] state</span><span class="s0">, double</span><span class="s1">[] action</span><span class="s0">, double </span><span class="s1">newQvalue){</span>
        <span class="s0">double</span><span class="s1">[] normalizeInput = normalizeInput(state</span><span class="s0">,</span><span class="s1">action)</span><span class="s0">;</span>
        <span class="s0">double </span><span class="s1">normalizedQvalue = normalizeQ(newQvalue)</span><span class="s0">;</span>

        <span class="s1">ArrayList&lt;Double&gt; NewInput = convertArrayToArrayList(normalizeInput)</span><span class="s0">;</span>
        <span class="s0">int </span><span class="s1">n=</span><span class="s2">10</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(trainingOutput.size()&lt;n) {</span>
            <span class="s1">trainingInput.add(NewInput)</span><span class="s0">;</span>
            <span class="s1">trainingOutput.add(normalizedQvalue)</span><span class="s0">;</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
            <span class="s1">trainingOutput.remove(</span><span class="s2">0</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">trainingInput.remove(</span><span class="s2">0</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">trainingInput.add(NewInput)</span><span class="s0">;</span>
            <span class="s1">trainingOutput.add(normalizedQvalue)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">arrayTrainingInput = convert2DArrayListTo2DArray(trainingInput)</span><span class="s0">;</span>
        <span class="s1">arrayTrainingOutput = convertArrayListToArray(trainingOutput)</span><span class="s0">;</span>
        <span class="s1">normalizedarrayTrainingOutput=normalizeOutput(arrayTrainingOutput)</span><span class="s0">;</span>

        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">i&lt;arrayTrainingOutput.length</span><span class="s0">;</span><span class="s1">i++){</span>
            <span class="s1">train(arrayTrainingInput[i]</span><span class="s0">,</span><span class="s1">normalizedarrayTrainingOutput[i])</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">private double </span><span class="s1">normalizeQ(</span><span class="s0">double </span><span class="s1">newQvalue) {</span>
        <span class="s0">double </span><span class="s1">normalizedQ=newQvalue/</span><span class="s2">10</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(normalizedQ&gt;</span><span class="s2">1</span><span class="s1">){</span>
            <span class="s1">normalizedQ=</span><span class="s2">1</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(normalizedQ&lt;-</span><span class="s2">1</span><span class="s1">){</span>
            <span class="s1">normalizedQ=-</span><span class="s2">1</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">normalizedQ</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">public double</span><span class="s1">[] normalizeInput (</span><span class="s0">double</span><span class="s1">[] state</span><span class="s0">, double</span><span class="s1">[] action){</span>
        <span class="s0">double</span><span class="s1">[] normalizedstate = normalizestate(state)</span><span class="s0">;</span>
        <span class="s0">double</span><span class="s1">[] normalizedaction = normalizeaction(action)</span><span class="s0">;</span>
        <span class="s0">double </span><span class="s1">[] normalizedInput = </span><span class="s0">new double</span><span class="s1">[normalizedstate.length+normalizedaction.length]</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">i&lt;normalizedInput.length</span><span class="s0">;</span><span class="s1">i++){</span>
            <span class="s0">if </span><span class="s1">(i&lt;normalizedstate.length){</span>
                <span class="s1">normalizedInput[i]=normalizedstate[i]</span><span class="s0">;</span>
            <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
                <span class="s1">normalizedInput[i]=normalizedaction[i-normalizedstate.length]</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">normalizedInput</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">public double</span><span class="s1">[] normalizeOutput (</span><span class="s0">double</span><span class="s1">[] input){</span>
        <span class="s0">double</span><span class="s1">[] output = </span><span class="s0">new double</span><span class="s1">[input.length]</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">i&lt;input.length</span><span class="s0">;</span><span class="s1">i++){</span>
            <span class="s1">output[i] = input[i]/</span><span class="s2">10</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(output[i]&lt;-</span><span class="s2">1</span><span class="s1">){</span>
                <span class="s1">output[i]=-</span><span class="s2">1</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(output[i]&gt;</span><span class="s2">1</span><span class="s1">){</span>
                <span class="s1">output[i]=</span><span class="s2">1</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">output</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">public static double </span><span class="s1">[] normalizestate(</span><span class="s0">double </span><span class="s1">[] states) {</span>
        <span class="s0">double </span><span class="s1">[] normalizedStates = </span><span class="s0">new double </span><span class="s1">[</span><span class="s2">6</span><span class="s1">]</span><span class="s0">;</span>
        <span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s2">0</span><span class="s0">; </span><span class="s1">i &lt; </span><span class="s2">6</span><span class="s0">; </span><span class="s1">i++) {</span>
            <span class="s0">switch </span><span class="s1">(i) {</span>
                <span class="s0">case </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s1">normalizedStates[</span><span class="s2">0</span><span class="s1">] = -</span><span class="s2">1.0 </span><span class="s1">+ states[</span><span class="s2">0</span><span class="s1">] *</span><span class="s2">2.0</span><span class="s1">/((</span><span class="s0">double</span><span class="s1">)(State.NumHeading-</span><span class="s2">1</span><span class="s1">))</span><span class="s0">;</span>
                    <span class="s0">break;</span>
                <span class="s0">case </span><span class="s2">1</span><span class="s1">:</span>
                    <span class="s1">normalizedStates[</span><span class="s2">1</span><span class="s1">] = -</span><span class="s2">1.0 </span><span class="s1">+ states[</span><span class="s2">1</span><span class="s1">] *</span><span class="s2">2.0</span><span class="s1">/((</span><span class="s0">double</span><span class="s1">)(State.NumTargetDistance-</span><span class="s2">1</span><span class="s1">))</span><span class="s0">;;</span>
                    <span class="s0">break;</span>
                <span class="s0">case </span><span class="s2">2</span><span class="s1">:</span>
                    <span class="s1">normalizedStates[</span><span class="s2">2</span><span class="s1">] = -</span><span class="s2">1.0 </span><span class="s1">+ states[</span><span class="s2">2</span><span class="s1">] *</span><span class="s2">2.0</span><span class="s1">/((</span><span class="s0">double</span><span class="s1">)(State.NumTargetBearing-</span><span class="s2">1</span><span class="s1">))</span><span class="s0">;;</span>
                    <span class="s0">break;</span>
                <span class="s0">case </span><span class="s2">3</span><span class="s1">:</span>
                    <span class="s1">normalizedStates[</span><span class="s2">3</span><span class="s1">] = -</span><span class="s2">1.0 </span><span class="s1">+ states[</span><span class="s2">3</span><span class="s1">] *</span><span class="s2">2.0</span><span class="s0">;</span>
                    <span class="s0">break;</span>
                <span class="s0">case </span><span class="s2">4</span><span class="s1">:</span>
                    <span class="s1">normalizedStates[</span><span class="s2">4</span><span class="s1">] = -</span><span class="s2">1.0 </span><span class="s1">+ states[</span><span class="s2">4</span><span class="s1">] *</span><span class="s2">2.0</span><span class="s0">;</span>
                    <span class="s0">break;</span>
                <span class="s0">case </span><span class="s2">5</span><span class="s1">:</span>
                    <span class="s1">normalizedStates[</span><span class="s2">5</span><span class="s1">] = -</span><span class="s2">1.0 </span><span class="s1">+ states[</span><span class="s2">5</span><span class="s1">] *</span><span class="s2">2.0</span><span class="s0">;</span>
                    <span class="s0">break;</span>
                <span class="s0">default</span><span class="s1">:</span>
                    <span class="s1">System.out.println(</span><span class="s6">&quot;The data doesn't belong here.&quot;</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">normalizedStates</span><span class="s0">;</span>
    <span class="s1">}</span>


    <span class="s0">public static double </span><span class="s1">[] normalizeaction(</span><span class="s0">double </span><span class="s1">[] actions) {</span>
        <span class="s0">double </span><span class="s1">[] normalizedActions = </span><span class="s0">new double </span><span class="s1">[</span><span class="s2">5</span><span class="s1">]</span><span class="s0">;</span>
        <span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s2">0</span><span class="s0">; </span><span class="s1">i &lt; </span><span class="s2">5</span><span class="s0">; </span><span class="s1">i++) {</span>
            <span class="s0">switch </span><span class="s1">(i) {</span>
                <span class="s0">case </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s1">normalizedActions[</span><span class="s2">0</span><span class="s1">] = -</span><span class="s2">1.0 </span><span class="s1">+ actions[</span><span class="s2">0</span><span class="s1">] *</span><span class="s2">2.0</span><span class="s1">/((</span><span class="s0">double</span><span class="s1">)(Action.RobotAhead-</span><span class="s2">1</span><span class="s1">))</span><span class="s0">;</span>
                    <span class="s0">break;</span>
                <span class="s0">case </span><span class="s2">1</span><span class="s1">:</span>
                    <span class="s1">normalizedActions[</span><span class="s2">1</span><span class="s1">] = -</span><span class="s2">1.0 </span><span class="s1">+ actions[</span><span class="s2">1</span><span class="s1">] *</span><span class="s2">2.0</span><span class="s1">/((</span><span class="s0">double</span><span class="s1">)(Action.RobotBack-</span><span class="s2">1</span><span class="s1">))</span><span class="s0">;</span>
                    <span class="s0">break;</span>
                <span class="s0">case </span><span class="s2">2</span><span class="s1">:</span>
                    <span class="s1">normalizedActions[</span><span class="s2">2</span><span class="s1">] = -</span><span class="s2">1.0 </span><span class="s1">+ actions[</span><span class="s2">2</span><span class="s1">] *</span><span class="s2">2.0</span><span class="s1">/((</span><span class="s0">double</span><span class="s1">)(Action.RobotAheadTurnLeft-</span><span class="s2">1</span><span class="s1">))</span><span class="s0">;</span>
                    <span class="s0">break;</span>
                <span class="s0">case </span><span class="s2">3</span><span class="s1">:</span>
                    <span class="s1">normalizedActions[</span><span class="s2">3</span><span class="s1">] = -</span><span class="s2">1.0 </span><span class="s1">+ actions[</span><span class="s2">3</span><span class="s1">] *</span><span class="s2">2.0</span><span class="s1">/((</span><span class="s0">double</span><span class="s1">)(Action.RobotAheadTurnRight-</span><span class="s2">1</span><span class="s1">))</span><span class="s0">;</span>
                    <span class="s0">break;</span>
                <span class="s0">case </span><span class="s2">4</span><span class="s1">:</span>
                    <span class="s1">normalizedActions[</span><span class="s2">4</span><span class="s1">] = -</span><span class="s2">1.0 </span><span class="s1">+ actions[</span><span class="s2">4</span><span class="s1">] *</span><span class="s2">2.0</span><span class="s0">;</span>
                    <span class="s0">break;</span>
                <span class="s0">default</span><span class="s1">:</span>
                    <span class="s1">System.out.println(</span><span class="s6">&quot;The data doesn't belong here.&quot;</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">normalizedActions</span><span class="s0">;</span>
    <span class="s1">}</span>



    <span class="s0">private boolean </span><span class="s1">deepEquals(</span><span class="s0">double</span><span class="s1">[] array1</span><span class="s0">,double</span><span class="s1">[] array2){</span>
        <span class="s0">if </span><span class="s1">(array1.length !=array2.length){</span>
            <span class="s0">return false;</span>
        <span class="s1">}</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">i&lt;array1.length</span><span class="s0">;</span><span class="s1">i++){</span>
            <span class="s0">if </span><span class="s1">(array1[i]!=array2[i]){</span>
                <span class="s0">return false;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return true;</span>
    <span class="s1">}</span>

    <span class="s0">private </span><span class="s1">ArrayList&lt;Double&gt; convertArrayToArrayList(</span><span class="s0">double</span><span class="s1">[] input) {</span>
        <span class="s1">ArrayList&lt;Double&gt; output= </span><span class="s0">new </span><span class="s1">ArrayList&lt;Double&gt;()</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">i&lt;input.length</span><span class="s0">;</span><span class="s1">i++){</span>
            <span class="s1">output.add(input[i])</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">output</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">private double</span><span class="s1">[] convertArrayListToArray(ArrayList&lt;Double&gt; input) {</span>
        <span class="s0">double</span><span class="s1">[] output= </span><span class="s0">new double</span><span class="s1">[input.size()]</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">i&lt;output.length</span><span class="s0">;</span><span class="s1">i++){</span>
            <span class="s1">output[i]= input.get(i)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">output</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">private double</span><span class="s1">[][] convert2DArrayListTo2DArray(ArrayList&lt;ArrayList&lt;Double&gt;&gt; input) {</span>
        <span class="s0">double</span><span class="s1">[][] output= </span><span class="s0">new double</span><span class="s1">[input.size()][</span><span class="s2">11</span><span class="s1">]</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">i&lt;input.size()</span><span class="s0">;</span><span class="s1">i++){</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">j=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">j&lt;input.get(i).size()</span><span class="s0">;</span><span class="s1">j++){</span>
                <span class="s1">output[i][j]=input.get(i).get(j)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">output</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">public int </span><span class="s1">trainModel(</span><span class="s0">double</span><span class="s1">[][] X</span><span class="s0">,double </span><span class="s1">[]y) {</span>
        <span class="s0">double </span><span class="s1">result</span><span class="s0">;</span>
        <span class="s0">double </span><span class="s1">totalerror=</span><span class="s2">1</span><span class="s0">;</span>
        <span class="s0">double</span><span class="s1">[] error=</span><span class="s0">new double</span><span class="s1">[y.length]</span><span class="s0">;</span>
        <span class="s1">Arrays.fill(error</span><span class="s0">,</span><span class="s2">1.0</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">int </span><span class="s1">round=</span><span class="s2">0</span><span class="s0">;</span>
        <span class="s0">int </span><span class="s1">i=</span><span class="s2">0</span><span class="s0">;</span>
        <span class="s0">while </span><span class="s1">(Math.abs(totalerror)&gt;=</span><span class="s2">1</span><span class="s1">) {</span>
            <span class="s1">result = outputFor(X[i%y.length])</span><span class="s0">;</span>
            <span class="s1">outputError(y[i%y.length]</span><span class="s0">, </span><span class="s1">result)</span><span class="s0">;</span>
            <span class="s1">weightUpdate(</span><span class="s2">1</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">hiddenErrors()</span><span class="s0">;</span>
            <span class="s1">weightUpdate(</span><span class="s2">0</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">error[i%X.length]=(result-y[i%y.length])*(result-y[i%y.length])</span><span class="s0">;</span>
            <span class="s1">totalerror = calculatetotalerror(error)</span><span class="s0">;</span>
            <span class="s1">i=i+</span><span class="s2">1</span><span class="s0">;</span>
            <span class="s1">round+=</span><span class="s2">1</span><span class="s0">;</span>
            <span class="s1">System.out.print(round+</span><span class="s6">&quot;,&quot;</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">System.out.println(totalerror)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(round&gt;</span><span class="s2">50000</span><span class="s1">){</span>
                <span class="s0">break;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">round</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">private double </span><span class="s1">calculatetotalerror(</span><span class="s0">double</span><span class="s1">[] error){</span>
        <span class="s0">double </span><span class="s1">totalerror=</span><span class="s2">0</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">i&lt;error.length</span><span class="s0">;</span><span class="s1">i++){</span>
            <span class="s1">totalerror=totalerror+error[i]</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">totalerror=Math.sqrt(totalerror)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">totalerror</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s0">public void </span><span class="s1">save(File argFile) </span><span class="s0">throws </span><span class="s1">IOException {</span>
        <span class="s1">StringBuilder builder = </span><span class="s0">new </span><span class="s1">StringBuilder()</span><span class="s0">;</span>
        <span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s2">0</span><span class="s0">; </span><span class="s1">i &lt; weight.length</span><span class="s0">; </span><span class="s1">i++)</span><span class="s3">//for each row</span>
        <span class="s1">{</span>
            <span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">j = </span><span class="s2">0</span><span class="s0">; </span><span class="s1">j &lt; weight[i].length</span><span class="s0">; </span><span class="s1">j++)</span><span class="s3">//for each column</span>
            <span class="s1">{</span>
                <span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">k=</span><span class="s2">0</span><span class="s0">;</span><span class="s1">k&lt;weight[i][j].length</span><span class="s0">;</span><span class="s1">k++) {</span>
                    <span class="s1">builder.append(i+</span><span class="s6">&quot;,&quot;</span><span class="s1">)</span><span class="s0">;</span>
                    <span class="s1">builder.append(j+</span><span class="s6">&quot;,&quot;</span><span class="s1">)</span><span class="s0">;</span>
                    <span class="s1">builder.append(k+</span><span class="s6">&quot;,&quot;</span><span class="s1">)</span><span class="s0">;</span>
                    <span class="s1">builder.append(weight[i][j][k] + </span><span class="s6">&quot;&quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s3">//append to the output string</span>
                    <span class="s1">builder.append(</span><span class="s6">&quot;</span><span class="s0">\n</span><span class="s6">&quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s3">//append remark a at the end of the row</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

        <span class="s1">}</span>
        <span class="s1">BufferedWriter writer = </span><span class="s0">new </span><span class="s1">BufferedWriter(</span><span class="s0">new </span><span class="s1">FileWriter(argFile))</span><span class="s0">;</span>
        <span class="s1">writer.write(builder.toString())</span><span class="s0">;</span><span class="s3">//save the string representation of the board</span>
        <span class="s1">writer.close()</span><span class="s0">;</span>

    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s0">public void </span><span class="s1">load(File argFile) </span><span class="s0">throws </span><span class="s1">IOException {</span>
        <span class="s1">BufferedReader reader = </span><span class="s0">new </span><span class="s1">BufferedReader(</span><span class="s0">new </span><span class="s1">FileReader(argFile))</span><span class="s0">;</span>
        <span class="s1">String line = </span><span class="s6">&quot;&quot;</span><span class="s0">;</span>
        <span class="s0">while</span><span class="s1">((line = reader.readLine()) != </span><span class="s0">null</span><span class="s1">)</span>
        <span class="s1">{</span>
            <span class="s1">String[] cols = line.split(</span><span class="s6">&quot;,&quot;</span><span class="s1">)</span><span class="s0">; </span><span class="s3">//note that if you have used space as separator you have to split on &quot; &quot;</span>
            <span class="s0">int </span><span class="s1">i=Integer.parseInt(cols[</span><span class="s2">0</span><span class="s1">])</span><span class="s0">;</span>
            <span class="s0">int </span><span class="s1">j=Integer.parseInt(cols[</span><span class="s2">1</span><span class="s1">])</span><span class="s0">;</span>
            <span class="s0">int </span><span class="s1">k=Integer.parseInt(cols[</span><span class="s2">2</span><span class="s1">])</span><span class="s0">;</span>
            <span class="s0">double </span><span class="s1">w=Double.parseDouble(cols[</span><span class="s2">3</span><span class="s1">])</span><span class="s0">;</span>
            <span class="s1">weight[i][j][k]=w</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">reader.close()</span><span class="s0">;</span>
    <span class="s1">}</span>

<span class="s1">}</span>
</pre>
</body>
</html>